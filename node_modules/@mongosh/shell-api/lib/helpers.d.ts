import type { DbOptions, Document, ExplainVerbosityLike, FindOneAndDeleteOptions, FindOneAndReplaceOptions, FindOneAndUpdateOptions, DeleteOptions, MapReduceOptions, ExplainOptions, ServiceProvider } from '@mongosh/service-provider-core';
import type { Database } from './database';
import type { Collection } from './collection';
import type { CursorIterationResult } from './result';
import type { ReplPlatform } from '@mongosh/service-provider-core';
import type { ClientSideFieldLevelEncryptionOptions } from './field-level-encryption';
import type { AutoEncryptionOptions, Long, ObjectId, Timestamp } from 'mongodb';
import type { AbstractFiniteCursor } from './abstract-cursor';
import type ChangeStreamCursor from './change-stream-cursor';
import type { BSON, ShellBson } from '@mongosh/shell-bson';
import type { MQLPipeline, MQLQuery } from './mql-types';
export declare function adaptAggregateOptions(options?: any): {
    aggOptions: Document;
    dbOptions: DbOptions;
    explain?: ExplainVerbosityLike & string;
};
export declare function validateExplainableVerbosity(verbosity?: ExplainVerbosityLike): ExplainVerbosityLike & string;
export declare const onlyShardedCollectionsInConfigFilter: {
    readonly dropped: {
        readonly $ne: true;
    };
    readonly unsplittable: {
        readonly $ne: true;
    };
};
export declare function assertArgsDefinedType(args: any[], expectedTypes: Array<true | string | Array<string | undefined>>, func?: string): void;
export declare function assertKeysDefined(object: any, keys: string[]): void;
export declare function adaptOptions(shellToCommand: any, additions: any, shellDoc: any): any;
export declare function processDigestPassword(username: string, passwordDigestor: 'server' | 'client', command: {
    pwd: string;
}, sp: ServiceProvider): Promise<{
    digestPassword?: boolean;
    pwd?: string;
}>;
export declare function getPrintableShardStatus(configDB: Database, verbose: boolean): Promise<ShardingStatusResult>;
export type ShardInfo = {
    _id: string;
    host: string;
    state: number;
    tags?: string[];
    topologyTime: Timestamp;
    replSetConfigVersion: Long;
};
export type ShardingStatusResult = {
    shardingVersion: {
        _id: number;
        clusterId: ObjectId;
        currentVersion?: number;
    };
    shards: ShardInfo[];
    [mongoses: `${string} mongoses`]: 'none' | {
        [version: string]: number | {
            up: number;
            waiting: boolean;
        };
    }[];
    autosplit: {
        'Currently enabled': 'yes' | 'no';
    };
    automerge?: {
        'Currently enabled': 'yes' | 'no';
    };
    balancer: {
        'Currently enabled': 'yes' | 'no';
        'Currently running': 'yes' | 'no' | 'unknown';
        'Failed balancer rounds in last 5 attempts': number;
        'Migration Results for the last 24 hours': 'No recent migrations' | {
            [count: number]: 'Success' | `Failed with error '${string}', from ${string} to ${string}`;
        };
        'Balancer active window is set between'?: `${string} and ${string} server local time`;
        'Last reported error'?: string;
        'Time of Reported error'?: string;
        'Collections with active migrations'?: `${string} started at ${string}`[];
    };
    shardedDataDistribution?: ShardedDataDistribution;
    databases: {
        database: Document;
        collections: Document;
    }[];
};
export type ShardedDataDistribution = {
    ns: string;
    shards: {
        shardName: string;
        numOrphanedDocs: number;
        numOwnedDocuments: number;
        orphanedSizeBytes: number;
        ownedSizeBytes: number;
    }[];
}[];
export declare function getConfigDB(db: Database): Promise<Database>;
type AnyBsonNumber = number | BSON['Long']['prototype'] | BSON['Int32']['prototype'] | BSON['Double']['prototype'];
export declare function coerceToJSNumber(n: AnyBsonNumber): number;
export declare function dataFormat(bytes?: number): string;
export declare function scaleIndividualShardStatistics(shardStats: Document, scale: number): Document;
export declare function tsToSeconds(x: BSON['Timestamp']['prototype'] | number | {
    valueOf(): number;
}): number;
export declare function addHiddenDataProperty<T = any>(target: T, key: string | symbol, value: any): T;
export declare function iterate(results: CursorIterationResult, cursor: AbstractFiniteCursor<any> | ChangeStreamCursor, batchSize: number): Promise<CursorIterationResult>;
export type FindAndModifyMethodShellOptions = {
    query: MQLQuery;
    sort?: (FindOneAndDeleteOptions | FindOneAndReplaceOptions | FindOneAndUpdateOptions)['sort'];
    update?: Document | Document[];
    remove?: boolean;
    new?: boolean;
    fields?: Document;
    projection?: Document;
    upsert?: boolean;
    bypassDocumentValidation?: boolean;
    writeConcern?: Document;
    collation?: (FindOneAndDeleteOptions | FindOneAndReplaceOptions | FindOneAndUpdateOptions)['collation'];
    arrayFilters?: Document[];
    explain?: ExplainVerbosityLike;
};
export type FindAndModifyShellOptions<BaseOptions extends FindOneAndReplaceOptions | FindOneAndUpdateOptions> = BaseOptions & {
    returnOriginal?: boolean;
    returnNewDocument?: boolean;
    new?: boolean;
};
export declare function processFindAndModifyOptions<BaseOptions extends FindOneAndReplaceOptions | FindOneAndUpdateOptions>(options: FindAndModifyShellOptions<BaseOptions>): BaseOptions;
export type RemoveShellOptions = DeleteOptions & {
    justOne?: boolean;
};
export declare function processRemoveOptions(options: boolean | RemoveShellOptions): RemoveShellOptions;
export type MapReduceShellOptions = Document | string;
export declare function processMapReduceOptions(optionsOrOutString: MapReduceShellOptions): MapReduceOptions;
export declare function setHideIndex(coll: Collection, index: string | Document, hidden: boolean): Promise<Document>;
export declare function assertCLI(platform: ReplPlatform, features: string): void;
export declare function processFLEOptions(fleOptions: ClientSideFieldLevelEncryptionOptions): AutoEncryptionOptions;
type NotAPromise = {
    [key: string]: any;
    then?: never;
};
export declare function maybeMarkAsExplainOutput<T extends NotAPromise>(value: T, options: ExplainOptions): T;
export declare function markAsExplainOutput<T extends NotAPromise>(value: T): T;
export declare function isValidDatabaseName(name: string): boolean;
export declare function isValidCollectionName(name: string): boolean;
export declare function shouldRunAggregationImmediately(pipeline: MQLPipeline): boolean;
export declare function adjustRunCommand(cmd: Document, shellBson: ShellBson): Document;
export declare function getBadge(collections: Document[], index: number): string;
export declare function shallowClone<T>(input: T): T;
export declare function buildConfigChunksCollectionMatch(configCollectionsInfo: Document): Document;
export interface GenericCollectionSchema {
    schema: Document;
}
export interface GenericDatabaseSchema {
    [key: string]: GenericCollectionSchema;
}
export interface GenericServerSideSchema {
    [key: string]: GenericDatabaseSchema;
}
export type StringKey<T> = keyof T & string;
export declare const aggregateBackgroundOptionNotSupportedHelp: string;
export type SearchIndexDefinition = Document;
export {};
